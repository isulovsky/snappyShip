#include "$FOAM_CASE/system/shipDict";

//------   hullBox parameters-------//
posLengthHelp #eval {1*$shipParameters.length};
negLengthHelp #eval {-0.08*$shipParameters.length};
negBHelp #eval {-1.2*$shipParameters.beam};
posBHelp #eval {1.2*$shipParameters.beam};
dHelp #eval {$shipParameters.freeboard*1.05};
tHelp #eval {$shipParameters.draft * (-1.01)};
//------   kelvin2 parameters-------//
kelvin2posLengthHelp #eval {1.6*$shipParameters.length};
kelvin2negLengthHelp #eval {-1.6*$shipParameters.length};
kelvin2negBHelp #eval {-8.5*$shipParameters.beam};
kelvin2posBHelp #eval {8.5*$shipParameters.beam};
kelvin2upper #eval {1*$shipParameters.h};
kelvin2lower #eval {-1*$shipParameters.h};

//------   kelvin3 parameters-------//
kelvin3posLengthHelp #eval {1.4*$shipParameters.length};
kelvin3negLengthHelp #eval {-1.4*$shipParameters.length};
kelvin3negBHelp #eval {-6.5*$shipParameters.beam};
kelvin3posBHelp #eval {6.5*$shipParameters.beam};
kelvin3upper #eval {0.5*$shipParameters.h};
kelvin3lower #eval {-0.5*$shipParameters.h};

//------   kelvin4 parameters-------//
kelvin4posLengthHelp #eval {1.2*$shipParameters.length};
kelvin4negLengthHelp #eval {-1.2*$shipParameters.length};
kelvin4negBHelp #eval {-2.5*$shipParameters.beam};
kelvin4posBHelp #eval {2.5*$shipParameters.beam};
kelvin4upper #eval {0.25*$shipParameters.h};
kelvin4lower #eval {-0.25*$shipParameters.h};



geometry
{
   /*
    append.stl
    {
        type triSurfaceMesh;
        name append;

        patchInfo
        {
            type wall;
        }
     }

    deck.stl
    {
        type triSurfaceMesh;
        name deck;

        patchInfo
        {
            type wall;
        }
     }
*/
    hull.stl
    {
        type triSurfaceMesh;
        name hull;

        patchInfo
        {
            type wall;
        }
     }

    kelvin2.stl
     {

        type triSurfaceMesh;
        name kelvin2;

        patchInfo
        {
            type empty;
        }
     }
    kelvin3.stl
     {

        type triSurfaceMesh;
        name kelvin3;

        patchInfo
        {
            type empty;
        }
     }
    kelvin4.stl
     {
        type triSurfaceMesh;
        name kelvin4;

        patchInfo
        {
            type empty;
        }
     }
    hullBox
     {
      type searchableBox;
      min ($negLengthHelp $negBHelp $tHelp);
      max ($posLengthHelp $posBHelp $dHelp);

     }
}


// Settings for the castellatedMesh generation.
castellatedMeshControls
{

    // Refinement parameters
    // ~~~~~~~~~~~~~~~~~~~~~

    // If local number of cells is >= maxLocalCells on any processor
    // switches from from refinement followed by balancing
    // (current method) to (weighted) balancing before refinement.
    maxLocalCells 40000000;

    // Overall cell limit (approximately). Refinement will stop immediately
    // upon reaching this number so a refinement level might not complete.
    // Note that this is the number of cells before removing the part which
    // is not 'visible' from the keepPoint. The final number of cells might
    // actually be a lot less.
    maxGlobalCells 400000000;

    // The surface refinement loop might spend lots of iterations refining just a
    // few cells. This setting will cause refinement to stop if <= minimumRefine
    // are selected for refinement. Note: it will at least do one iteration
    // (unless the number of cells to refine is 0)
    minRefinementCells 0;

    // Number of buffer layers between different levels.
    // 1 means normal 2:1 refinement restriction, larger means slower
    // refinement.
    nCellsBetweenLevels 1;



    // Explicit feature edge refinement
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Specifies a level for any cell intersected by its edges.
    // This is a featureEdgeMesh, read from constant/triSurface for now.
    features
    (
         {
             file "hull.eMesh";
             level 6;
         }



    );



    // Surface based refinement
    // ~~~~~~~~~~~~~~~~~~~~~~~~

    // Specifies two levels for every surface. The first is the minimum level,
    // every cell intersecting a surface gets refined up to the minimum level.
    // The second level is the maximum level. Cells that 'see' multiple
    // intersections where the intersections make an
    // angle > resolveFeatureAngle get refined up to the maximum level.

    refinementSurfaces
    {
        hull
        {
            // Surface-wise min and max refinement level
            level (6 6);

        }
/*
        deck
        {
            // Surface-wise min and max refinement level
            level (2 2);

        }

*/

    }

    resolveFeatureAngle 20;


    // Region-wise refinement
    // ~~~~~~~~~~~~~~~~~~~~~~

    // Specifies refinement level for cells in relation to a surface. One of
    // three modes
    // - distance. 'levels' specifies per distance to the surface the
    //   wanted refinement level. The distances need to be specified in
    //   descending order.
    // - inside. 'levels' is only one entry and only the level is used. All
    //   cells inside the surface get refined up to the level. The surface
    //   needs to be closed for this to be possible.
    // - outside. Same but cells outside.

   refinementRegions
  {

     hull
     {
       mode distance;
       levels ((0.1 6)(0.5 4)(1 3));
     }

    kelvin2
     {
       mode inside;
       levels ((0.5 2));
     }

    kelvin3
     {
       mode inside;
       levels ((0.5 3));
     }
    kelvin4
     {
       mode inside;
       levels ((0.5 4));
     }

    hullBox
     {
       mode inside;
       levels ((0.5 5));
     }

  }


    // Mesh selection
    // ~~~~~~~~~~~~~~

    // After refinement patches get added for all refinementSurfaces and
    // all cells intersecting the surfaces get put into these patches. The
    // section reachable from the locationInMesh is kept.
    // NOTE: This point should never be on a face, always inside a cell, even
    // after refinement.
    locationInMesh (-10.1 -8.1 -4.52);


    // Whether any faceZones (as specified in the refinementSurfaces)
    // are only on the boundary of corresponding cellZones or also allow
    // free-standing zone faces. Not used if there are no faceZones.
    allowFreeStandingZoneFaces true;


}
